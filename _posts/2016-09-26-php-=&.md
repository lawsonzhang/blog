---
layout: post
title:  "php &="
date:   2016-09-26
desc: "php引用 =& 详解"
keywords: "php, =&, 引用"
categories: [PHP]
tags: [php]
icon: icon-php
---

### 引用是什么
-------------
> 在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针，它们是符号表别名。注意在 PHP 中，变量名和变量内容是不一样的，因此同样的内容可以有不同的名字。最接近的比喻是 Unix 的文件名和文件本身 － 变量名是目录条目，而变量内容则是文件本身。引用可以被看作是 Unix 文件系统中的紧密连接。 

### 引用做什么
-------------
> PHP 的引用允许你用两个变量来指向同一个内容。

> 意思是，当你这样做时：
``` php
<?php
    $a =& $b
?> 
```
> 这意味着 $a 和 $b 指向了同一个变量。 
#####  ``注: $a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。``
>
>
> 同样的语法可以用在函数中，它返回引用，以及用在 new 运算符中（PHP 4.0.4 以及以后版本）：
``` php
<?php
    $bar =& new fooclass();
    $foo =& find_var ($bar);
?> 
```
#####  ``注: 不用 & 运算符导致对象生成了一个拷贝。如果你在类中用 $this，它将作用于该类当前的实例。没有用 & 的赋值将拷贝这个实例（例如对象）并且 $this 将作用于这个拷贝上，这并不总是想要的结果。由于性能和内存消耗的问题，通常你只想工作在一个实例上面。 ``
>
> 尽管你可以用 @ 运算符来关闭构造函数中的任何错误信息，例如用 @new，但用 &new 语句时这不起效果。这是 Zend 引擎的一个限制并且会导致一个解析错误。
> 
> 引用做的第二件事是用引用传递变量。这是通过在函数内建立一个本地变量并且该变量在呼叫范围内引用了同一个内容来实现的。例如：
``` php
<?php
    function foo (&$var)
    {
        $var++;
    }
    $a = 5;
    foo($a);
?> 
```
> 将使 $a 变成 6。这是因为在 foo 函数中变量 $var 指向了和 $a 指向的同一个内容。更多详细解释见引用传递。 
>
> 引用做的第三件事是引用返回。


### 引用不是什么
-------------
> 如前所述，引用不是指针。

> 这意味着下面的结构不会产生你预期的效果： 
``` php
<?php
    function foo (&$var)
    {
        $var =& $GLOBALS["baz"];
    }
    foo($bar);
?> 
```
> 这将使 foo 函数中的 $var 变量在函数调用时和 $bar 绑定在一起，但接着又被重新绑定到了 $GLOBALS["baz"] 上面。
>
> 不可能通过引用机制将 $bar 在函数调用范围内绑定到别的变量上面，因为在函数 foo 中并没有变量 $bar（它被表示为 $var，但是 $var 只有变量内容而没有调用符号表中的名字到值的绑定）。


### 引用传递
-------------
> 你可以将一个变量通过引用传递给函数，这样该函数就可以修改其参数的值。

> 语法如下：
``` php
<?php
    function foo (&$var)
    {
        $var++;
    }
    $a = 5;
    foo($a);
    // $a is 6 here
?>
```
> 注意在函数调用时没有引用符号 － 只有函数定义中有。光是函数定义就足够使参数通过引用来正确传递了。
>
> 以下内容可以通过引用传递
>
> 变量，例如 foo($a)
> 
> New 语句，例如 foo(new foobar()) 
>
> 从函数中返回的引用，例如：
``` php
<?php
    function &bar()
    {
        $a = 5;
        return $a;
    }
    foo(bar());
?>
```
> 详细解释见引用返回。
>
> 任何其它表达式都不能通过引用传递，结果未定义。例如下面引用传递的例子是无效的：
``` php
<?php
    function bar() // Note the missing &
    {
        $a = 5;
        return $a;
    }
    foo(bar());
    foo($a = 5) // 表达式，不是变量
    foo(5) // 常量，不是变量
?> 
```
> 这些条件是 PHP 4.0.4 以及以后版本有的。 


### 引用返回
-------------
> 引用返回用在当你想用函数找到引用应该被绑定在哪一个变量上面时。

> 当返回引用时，使用此语法：
``` php
<?php
    function &find_var ($param)
    {
        /* ...code... */
        return $found_var;
    }
    $foo =& find_var($bar);
    $foo->x = 2;
?> 
```
>
> 本例中 find_var 函数所返回的对象的属性将被设定（译者：指的是 $foo->x = 2; 语句），而不是拷贝，就和没有用引用语法一样。
#####  ``注: 和参数传递不同，这里必须在两个地方都用 & 符号 － 来指出返回的是一个引用，而不是通常的一个拷贝，同样也指出 $foo 是作为引用的绑定，而不是通常的赋值。``

### 取消引用
-------------
> 当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。

> 这并不意味着变量内容被销毁了。例如： 
``` php
<?php
    $a = 1;
    $b =& $a;
    unset ($a);
?> 
```
> 不会 unset $b，只是 $a。
> 
> 再拿这个和 Unix 的 unlink 调用来类比一下可能有助于理解。

### 引用定位
-------------
> 许多 PHP 的语法结构是通过引用机制实现的，所以上述有关引用绑定的一切也都适用于这些结构。

> 一些结构，例如引用传递和返回，已经在上面提到了。其它使用引用的结构有：
> 
> global 引用
> 
> 当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：
``` php
<?php
    $var =& $GLOBALS["var"];
?> 
```
> 这意味着，例如，unset $var 不会 unset 全局变量
>
> $this在一个对象的方法中，$this 永远是调用它的对象的引用。
``` php
<?php
	/**
	 * (C) CopyRight 2008 MagicToolBox - www.magictoolbox.com - support@magictoolbox.com
	**/
	require_once(DIR_FS_CATALOG . DIR_WS_MODULES . 'magictoolbox/magictoolbox_addons.php');
	$mod = magictoolboxLoadModule('MagicZoomPlus');
	$enabled = false;
	$main_page = isset($_REQUEST['main_page']) ? $_REQUEST['main_page'] : $_GET['main_page'];
	$cPath = isset($_REQUEST['cPath']) ? $_REQUEST['cPath'] : $_GET['cPath'];
	$products_id = isset($_REQUEST['products_id']) ? $_REQUEST['products_id'] : $_GET['products_id'];
	$scroll = false;
	if($mod->type == 'standard' && !$mod->params->checkValue('template', 'original') && $mod->params->checkValue('magicscroll', 'yes')) {
	    $scroll = magictoolboxLoadModule('magicscroll');
	　　$scroll->params->appendArray($mod->params->getArray());
	$scroll->params->set('direction', $mod->params->checkValue('template', array('left', 'right')) ? 'bottom' : 'right');
	}
	if(ZEN_MAGICZOOMPLUS_STATUS == 'true') {
	    $enable_on_block =  !$mod->params->checkValue('use-effect-on-whats-new-block', 'No') ||
	                        !$mod->params->checkValue('use-effect-on-specials-block', 'No') ||
	                        !$mod->params->checkValue('use-effect-on-featured-block', 'No');
	    if($mod->type == 'standard') {
	        if( (intval($cPath) > 0 && (!$mod->params->checkValue('use-effect-on-category-page', 'No') || $enable_on_block)) || // category page
	            (intval($products_id) > 0 && (!$mod->params->checkValue('use-effect-on-product-page', 'No') || $enable_on_block)) || // product page
	            ($main_page == 'products_new' && (!$mod->params->checkValue('use-effect-on-products-new-page', 'No') || $enable_on_block)) ||
	            ($main_page == 'products_all' && (!$mod->params->checkValue('use-effect-on-products-all-page', 'No') || $enable_on_block)) ||
	            ($main_page == 'advanced_search_result' && (!$mod->params->checkValue('use-effect-on-products-search-page', 'No') || $enable_on_block))
	        ) {
	            $enabled = true;
	        }
	    } elseif($mod->type == 'category' || $mod->type == 'circle') {
	        if( (intval($products_id) > 0 && (!$mod->params->checkValue('use-effect-on-product-page', 'No') || $enable_on_block)) || // product page
	            (intval($cPath) > 0 && $enable_on_block) || // category page
	            ($main_page == 'products_new' && $enable_on_block) ||
	            ($main_page == 'products_all' && $enable_on_block) ||
	            ($main_page == 'advanced_search_result' && $enable_on_block)
	        ) {
	            $enabled = true;
	        }
	    }
	}
	if (!$GLOBALS["MAGICZOOMPLUS_HEADERS_LOADED"] && $enabled) {
	    echo $mod->headers(DIR_WS_CATALOG . DIR_WS_TEMPLATE . 'jscript', DIR_WS_CATALOG . DIR_WS_TEMPLATE . 'css');
	    if($scroll) {
	        echo $scroll->headers(DIR_WS_CATALOG . DIR_WS_TEMPLATE . 'jscript', DIR_WS_CATALOG . DIR_WS_TEMPLATE . 'css');
	    }
	    $GLOBALS["MAGICZOOMPLUS_HEADERS_LOADED"] = true;
	}
?>
```