---
layout: post
title:  "秒杀、抢购活动设计"
date:   2016-10-26
desc: "秒杀、抢购活动设计"
keywords: "架构， 抢购， 消息队列"
categories: [PHP]
tags: [php]
icon: icon-php
---

## __秒杀阶段分析__
> * 秒杀前：用户访问宝贝描述页，不断刷新，等待秒杀开始
> * 秒杀中：用户点击秒杀按钮，洪水般的流量瞬间涌入系统，都想走在最前面，抢到宝贝
> * 秒杀后：秒杀结束，商品已被抢完或者秒杀时间已过，用户访问秒杀结束页面，整个秒杀阶段结束



## __难度挑战__
> * 秒杀前：大量用户频发刷新秒杀页面，都想第一个看到秒杀开始，越临近开始时间。刷新越频繁，这时候系统会承受巨大的读压力
> * 秒杀中：用户的秒杀请求短时间内持续涌入，前端访问量暴增，并且会牵扯到写库的需求，还有在对于单一热点商品库存判断和递减，由于写库是排他操作，一个一个排队处理，数据库写压力很大。
> * 秒杀后：和秒杀前类似，短时间内单页很多用户访问，但时间一过，页面就没有访问量了


## __解决方案__

### __服务器分制思想__
> * LVS、[Nginx反向代理](http://blog.lehehe.me/blog/)等增强服务器的抗压能力
> * 增加服务器的带宽
> * 数据库读写分离、[主从复制](http://blog.lehehe.me/blog/)增强数据库的读写能力
> * 适当增加数据库最大连接数

### __库存管理__
> 抢购秒杀最容易出现的库存管理问题，例如超卖等
>
> __[1]: MySQL数据库(基于事务(transcation)的原子性)__
>
> * 悲观锁
>>
>>  1. 利用MySQL innodb引擎的写独占锁
>>
>>  2. __SELECT__ * FROM table_name __FOR UPDATE__;    UPDATE table_name SET field_name = field_value - 1;
>
> * 乐观锁
>>
>>  1. 乐观的认为我每一次更新库存都不会因为并发而产生多扣库存，当一旦发现多扣产生，就执行数据回滚
>>
>>  2. 先执行UPDATE库存操作，发现库存小于0就执行回滚(__rollback__)
>
> __[2]: NOSQL(Redis)__
>>
>> Redis支持list类型存储，使用push、pop入列和出列，抢购库存大可分多条队列并行
>>
>> 进入队列后的用户可以排队下单，进入等待秒杀页面，未进入队列直接跳转活动结束页面
>>
>> 用PHP书写守护进程，while无限循环pop队列数据，执行下单操作
>> 
>> 也可以用其他MQ实现消息队列功能
>>
>> 这里还有一种以Redis为主，舍弃关系型数据库参与秒杀的方式
>>
>>> * 活动开始前先将秒杀的参与库存从总库存中去除，并加入Redis库存之中
>>> * 使用Redis的get和set操作Redis中的库存(Redis也支持transaction)
>>> * 秒杀活动下单执行另外一套扣除Redis库存逻辑
>>
> __[3]: 前端层面__
>
> * 用户在秒杀前访问的页面使用静态化处理，资源全部挂载在CDN
> * 使用动态加载JS方式判断秒杀开始: 去CDN请求一个JS，该JS用于秒杀开始后跳转秒杀页面使用，必须在秒杀开始之后生成，同理：秒杀页面也应该在活动开始之后生成
>

### __秒杀开始标志__
> * 服务器端统一在时间到之后，将某个开始标记打开(redis字段等)
> * 各节点不停请求服务器标记是否打开
